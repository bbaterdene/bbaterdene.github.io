<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<meta name="theme-color" content="#121212">
<title>Vocal Trainer Pro</title>
<style>
  :root {
    --bg: #121212;
    --panel: #1e1e1e;
    --primary: #00e676; /* Bright Green */
    --accent: #651fff;  /* Deep Purple */
    --text: #ffffff;
    --text-dim: #b0b0b0;
  }

  * { box-sizing: border-box; touch-action: none; -webkit-tap-highlight-color: transparent; }
  
  body {
    margin: 0; padding: 0;
    background: var(--bg); color: var(--text);
    font-family: 'Segoe UI', Roboto, Helvetica, sans-serif;
    height: 100dvh; width: 100vw;
    overflow: hidden;
    display: flex; flex-direction: column;
  }

  /* --- SCREENS --- */
  .screen {
    position: absolute; top: 0; left: 0; width: 100%; height: 100%;
    display: none; flex-direction: column; align-items: center; justify-content: center;
    background: var(--bg); z-index: 10;
    padding: 20px; overflow-y: auto;
  }
  .screen.active { display: flex; }

  /* --- TYPOGRAPHY --- */
  h1 { font-weight: 200; letter-spacing: 2px; margin-bottom: 20px; color: var(--primary); font-size: 2rem; }
  h2 { font-weight: 400; font-size: 1.1rem; color: var(--text-dim); margin-bottom: 10px; margin-top: 20px; }
  p { color: var(--text-dim); text-align: center; max-width: 400px; line-height: 1.5; }

  /* --- CONTROLS --- */
  .btn-group { display: flex; gap: 10px; margin: 15px 0; flex-wrap: wrap; justify-content: center; }
  
  button {
    background: var(--panel); border: 1px solid #333; color: var(--text);
    padding: 12px 20px; border-radius: 8px; font-size: 0.95rem;
    cursor: pointer; transition: transform 0.1s, background 0.2s;
    min-width: 80px; text-transform: uppercase; font-weight: 600; letter-spacing: 0.5px;
  }
  button:active { transform: scale(0.95); }
  
  /* Primary Action Buttons */
  button.primary { 
    background: var(--primary); color: #000; border: none; 
    box-shadow: 0 4px 15px rgba(0,230,118, 0.3); border-radius: 50px;
    padding: 15px 30px; min-width: 120px;
  }
  
  /* Manual Control Buttons (Small) */
  button.control {
    padding: 10px 10px; min-width: 60px; font-size: 0.8rem; background: #222;
  }

  button.secondary { background: transparent; border: 1px solid #555; }
  button.danger { color: #ff5252; border-color: #ff5252; }

  /* --- TOGGLES --- */
  .toggle-row {
    display: flex; background: #222; border-radius: 30px; padding: 5px; margin: 10px 0;
  }
  .toggle-row input { display: none; }
  .toggle-row label {
    padding: 10px 20px; cursor: pointer; color: #666; transition: 0.2s; border-radius: 30px;
  }
  .toggle-row input:checked + label { background: var(--primary); color: #000; font-weight: bold; }

  /* --- GAME HUD --- */
  #gameCanvas { width: 100%; height: 100%; display: block; }
  .hud-top {
    position: absolute; top: 20px; left: 0; width: 100%;
    display: flex; justify-content: space-between; padding: 0 20px;
    pointer-events: none; z-index: 20;
  }
  .score-box { font-size: 1.5rem; font-weight: bold; text-shadow: 0 2px 4px rgba(0,0,0,0.8); }
  .hud-bottom {
    position: absolute; bottom: 30px; width: 100%; text-align: center;
    pointer-events: none; z-index: 20;
  }
  #quitBtn { pointer-events: auto; padding: 10px 30px; font-size: 0.9rem; opacity: 0.7; }

  /* --- VOCAL RANGE VISUALIZER --- */
  #vrmVisualizer {
    width: 100%; max-width: 300px; height: 200px;
    background: #000; border-radius: 12px; border: 1px solid #333;
    position: relative; overflow: hidden; margin: 20px 0;
  }
  .vrm-bar {
    position: absolute; bottom: 0; left: 0; width: 100%; height: 4px;
    background: var(--primary); box-shadow: 0 0 15px var(--primary);
    transition: bottom 0.1s linear;
  }

  /* --- FEEDBACK FLOATING TEXT --- */
  .feedback {
    position: absolute; font-weight: 900; font-size: 2rem;
    animation: popUp 0.8s ease-out forwards; pointer-events: none;
    text-shadow: 0 2px 10px rgba(0,0,0,0.5);
  }
  @keyframes popUp {
    0% { transform: scale(0.5) translateY(0); opacity: 0; }
    20% { transform: scale(1.2) translateY(-10px); opacity: 1; }
    100% { transform: scale(1.0) translateY(-50px); opacity: 0; }
  }
</style>
</head>
<body>

<div id="screenMenu" class="screen active">
  <h1>VOCAL TRAINER</h1>
  
  <div style="text-align:center; width: 100%; max-width: 500px;">
    
    <div style="background: #1a1a1a; padding: 15px; border-radius: 12px; margin-bottom: 20px; border: 1px solid #333;">
      <h2 style="margin-top:0;">Range Settings</h2>
      <p id="rangeDisplay" style="color:var(--primary); font-weight:bold; font-size:1.4rem; margin: 10px 0;">C3 - G4</p>
      
      <div class="btn-group" style="margin-bottom: 10px;">
        <button class="control" onclick="App.shiftRange(-12)">Oct -</button>
        <button class="control" onclick="App.shiftRange(-1)">Note -</button>
        <button class="control" onclick="App.shiftRange(1)">Note +</button>
        <button class="control" onclick="App.shiftRange(12)">Oct +</button>
      </div>

      <button class="secondary" id="btnGoToRange" style="width: 100%; margin-top: 5px;">ðŸŽ¤ Auto-Measure Range</button>
    </div>

    <h2>Select Scale</h2>
    <div class="toggle-row" style="justify-content: center;">
      <input type="radio" name="scale" id="sMaj" value="major" checked><label for="sMaj">Major</label>
      <input type="radio" name="scale" id="sMin" value="minor"><label for="sMin">Minor</label>
      <input type="radio" name="scale" id="sChr" value="chromatic"><label for="sChr">Chrom</label>
    </div>

    <h2 style="margin-bottom: 15px;">Start Training</h2>
    <div class="btn-group">
      <button class="primary" onclick="App.startGame(1)">1 Note</button>
      <button class="primary" onclick="App.startGame(2)">2 Notes</button>
      <button class="primary" onclick="App.startGame(3)">3 Notes</button>
    </div>
  </div>
</div>

<div id="screenRange" class="screen">
  <h2>Vocal Range Finder</h2>
  <p>Sing from your lowest comfortable note up to your highest note.</p>
  
  <div id="vrmVisualizer">
    <div id="vrmIndicator" class="vrm-bar"></div>
    <div id="vrmHighMarker" style="position:absolute; right:10px; top:10px; font-size:0.8rem; color:#888;">High: -</div>
    <div id="vrmLowMarker" style="position:absolute; right:10px; bottom:10px; font-size:0.8rem; color:#888;">Low: -</div>
  </div>

  <div class="btn-group">
    <button class="secondary" onclick="App.stopRangeTest()">Back</button>
    <button class="primary" id="btnRangeAction" onclick="App.toggleRangeTest()">Start</button>
  </div>
</div>

<div id="screenGame" class="screen" style="padding:0; display:none;">
  <canvas id="gameCanvas"></canvas>
  
  <div class="hud-top">
    <div class="score-box" id="scoreDisplay">0</div>
    <div style="font-size:0.9rem; color:#888;">SEQ: <span id="seqDisplay">0</span>/10</div>
  </div>

  <div class="hud-bottom">
    <button id="quitBtn" class="danger" onclick="App.quitGame()">EXIT GAME</button>
  </div>
</div>

<script>
/**
 * APP ARCHITECTURE
 * 1. AudioEngine: Handles Mic & Pitch Detection (YIN)
 * 2. NoteSystem: Handles Frequency <-> Note conversion & Scale logic
 * 3. App: State management (Menu -> Game -> Results)
 */

const CONSTANTS = {
  YIN_THRESHOLD: 0.15,
  SMOOTHING: 0.15,
  NOTE_DURATION: 0.8, // Seconds per note
  NOTE_GAP: 0.2, // Silence between notes
  COIN_SPEED: 200, // Pixels per sec
  MIN_VOL: 0.01
};

// --- 1. AUDIO ENGINE ---
const AudioEngine = {
  ctx: null,
  analyser: null,
  buffer: null,
  mic: null,
  inited: false,

  async init() {
    if(this.inited) return true;
    try {
      this.ctx = new (window.AudioContext || window.webkitAudioContext)({ latencyHint: 'interactive' });
      const stream = await navigator.mediaDevices.getUserMedia({ audio: { echoCancellation: false, noiseSuppression: true, autoGainControl: false } });
      this.mic = this.ctx.createMediaStreamSource(stream);
      this.analyser = this.ctx.createAnalyser();
      this.analyser.fftSize = 2048;
      this.mic.connect(this.analyser);
      this.buffer = new Float32Array(this.analyser.fftSize);
      this.inited = true;
      return true;
    } catch(e) {
      alert("Microphone access denied.");
      return false;
    }
  },

  getPitch() {
    if(!this.inited) return null;
    this.analyser.getFloatTimeDomainData(this.buffer);
    
    // Simple RMS volume check
    let sum = 0; 
    for(let i=0; i<this.buffer.length; i++) sum += this.buffer[i]*this.buffer[i];
    if(Math.sqrt(sum/this.buffer.length) < CONSTANTS.MIN_VOL) return null;

    // YIN ALGORITHM
    const ns = this.buffer.length;
    const tauBuffer = new Float32Array(ns/2);
    for(let tau=0; tau<ns/2; tau++) {
      tauBuffer[tau] = 0;
      for(let i=0; i<ns/2; i++) {
        const delta = this.buffer[i] - this.buffer[i+tau];
        tauBuffer[tau] += delta*delta;
      }
    }
    tauBuffer[0] = 1;
    let runningSum = 0;
    for(let tau=1; tau<ns/2; tau++) {
      runningSum += tauBuffer[tau];
      tauBuffer[tau] *= tau/(runningSum || 1);
    }
    let tauEstimate = -1;
    for(let tau=1; tau<ns/2; tau++) {
      if(tauBuffer[tau] < CONSTANTS.YIN_THRESHOLD) {
        while(tau+1 < ns/2 && tauBuffer[tau+1] < tauBuffer[tau]) tau++;
        tauEstimate = tau; break;
      }
    }
    if(tauEstimate === -1) return null;
    
    // Parabolic Interpolation
    const x0 = tauEstimate - 1; const x2 = tauEstimate + 1;
    if(x0 < 0 || x2 >= ns/2) return this.ctx.sampleRate/tauEstimate;
    const s0 = tauBuffer[x0]; const s1 = tauBuffer[tauEstimate]; const s2 = tauBuffer[x2];
    let betterTau = tauEstimate + (s2 - s0) / (2 * (2 * s1 - s2 - s0));
    return this.ctx.sampleRate / betterTau;
  },

  playTone(freq, duration) {
    const o = this.ctx.createOscillator();
    const g = this.ctx.createGain();
    o.type = 'sine'; o.frequency.value = freq;
    o.connect(g); g.connect(this.ctx.destination);
    
    const now = this.ctx.currentTime;
    g.gain.setValueAtTime(0, now);
    g.gain.linearRampToValueAtTime(0.2, now + 0.05);
    g.gain.linearRampToValueAtTime(0, now + duration - 0.05);
    
    o.start(now); o.stop(now + duration);
  }
};

// --- 2. NOTE UTILS ---
const NoteSys = {
  NAMES: ['C','C#','D','D#','E','F','F#','G','G#','A','A#','B'],
  ftom(f) { return Math.round(12 * Math.log2(f/440) + 69); },
  mtof(m) { return 440 * Math.pow(2, (m-69)/12); },
  getName(m) { return this.NAMES[m%12]; }, // Note name only, no octave for cleaner UI if needed
  getFullName(m) { return this.NAMES[m%12] + (Math.floor(m/12)-1); },

  // Get only notes in specific scale
  getScaleNotes(rootMidi, rangeOctaves, scaleType) {
    const intervals = scaleType === 'major' ? [0,2,4,5,7,9,11] :
                      scaleType === 'minor' ? [0,2,3,5,7,8,10] :
                      [0,1,2,3,4,5,6,7,8,9,10,11];
    
    let notes = [];
    const maxMidi = rootMidi + (rangeOctaves * 12);
    
    for(let m = rootMidi; m <= maxMidi; m++) {
      // Modulo math to find if note fits interval from root
      const semitoneDist = (m - rootMidi) % 12;
      if(intervals.includes(semitoneDist)) {
        notes.push({ midi: m, freq: this.mtof(m), name: this.getFullName(m), isRoot: (semitoneDist===0) });
      }
    }
    return notes;
  }
};

// --- 3. APP LOGIC ---
const App = {
  state: 'MENU', // MENU, RANGE, GAME
  rootMidi: 48, // C3 default
  rangeOctaves: 1.5, // Default range for the game grid
  gameMode: 1, // 1, 2, or 3 notes
  
  // Game vars
  notes: [],
  playerY: 0,
  currFreq: 0,
  score: 0,
  seqCount: 0,
  isSpawning: false,
  coins: [],
  trail: [],
  particles: [],
  
  // Canvas
  canvas: document.getElementById('gameCanvas'),
  ctx: document.getElementById('gameCanvas').getContext('2d'),

  init() {
    this.updateRangeDisplay();
    this.resize();
    window.addEventListener('resize', () => this.resize());
    
    // Button Bindings
    document.getElementById('btnGoToRange').onclick = () => this.showRangeScreen();
    
    this.loop = this.loop.bind(this);
    requestAnimationFrame(this.loop);
  },

  resize() {
    this.canvas.width = window.innerWidth;
    this.canvas.height = window.innerHeight;
    // Re-render background if in game
    if(this.state === 'GAME') this.renderStaticBG();
  },

  // --- MANUAL RANGE CONTROLS (RESTORED) ---
  shiftRange(semitones) {
    this.rootMidi += semitones;
    // Cap reasonable limits (C2 to C6)
    if(this.rootMidi < 36) this.rootMidi = 36;
    if(this.rootMidi > 84) this.rootMidi = 84;
    this.updateRangeDisplay();
  },

  updateRangeDisplay() {
    const low = this.rootMidi;
    const high = Math.floor(this.rootMidi + (this.rangeOctaves * 12));
    document.getElementById('rangeDisplay').innerText = 
      `${NoteSys.getFullName(low)} - ${NoteSys.getFullName(high)}`;
  },

  // --- SCREENS ---
  showScreen(id) {
    document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
    document.getElementById(id).classList.add('active');
  },

  // --- RANGE TESTER ---
  showRangeScreen() {
    this.state = 'RANGE';
    this.showScreen('screenRange');
    this.rangeMin = Infinity; this.rangeMax = -Infinity;
    this.isListeningRange = false;
  },

  toggleRangeTest() {
    if(!this.isListeningRange) {
      AudioEngine.init().then(ok => {
        if(ok) {
          this.isListeningRange = true;
          document.getElementById('btnRangeAction').innerText = "Stop & Save";
          document.getElementById('btnRangeAction').classList.add('danger');
        }
      });
    } else {
      // Save
      this.isListeningRange = false;
      if(this.rangeMin < this.rangeMax) {
        // Snap to nearest C for cleaner scale logic
        const lowMidi = NoteSys.ftom(this.rangeMin);
        this.rootMidi = lowMidi;
        this.updateRangeDisplay();
      }
      this.stopRangeTest();
    }
  },

  stopRangeTest() {
    this.state = 'MENU';
    this.showScreen('screenMenu');
    document.getElementById('btnRangeAction').innerText = "Start";
    document.getElementById('btnRangeAction').classList.remove('danger');
  },

  // --- GAME START ---
  startGame(notesCount) {
    AudioEngine.init().then(ok => {
      if(!ok) return;
      
      this.gameMode = notesCount;
      const scaleType = document.querySelector('input[name="scale"]:checked').value;
      
      // GENERATE VALID NOTES FOR THE GRID
      this.gridNotes = NoteSys.getScaleNotes(this.rootMidi, this.rangeOctaves, scaleType);
      if(this.gridNotes.length < 5) { alert("Range too small or scale mismatch!"); return; }

      // Reset Vars
      this.score = 0; this.seqCount = 0;
      this.coins = []; this.trail = []; this.particles = [];
      this.isSpawning = false;
      document.getElementById('scoreDisplay').innerText = "0";
      
      this.state = 'GAME';
      this.showScreen('screenGame');
      this.renderStaticBG();
      
      this.spawnSequence(); // Start first wave
    });
  },

  quitGame() {
    this.state = 'MENU';
    this.showScreen('screenMenu');
  },

  // --- NOTE SPAWNING LOGIC ---
  spawnSequence() {
    if(this.state !== 'GAME') return;
    if(this.seqCount >= 10) { this.endGame(); return; }

    this.isSpawning = true;
    this.seqCount++;
    document.getElementById('seqDisplay').innerText = this.seqCount;

    // Pick 'gameMode' number of notes
    let sequence = [];
    let lastIdx = -1;

    for(let i=0; i<this.gameMode; i++) {
      // Pick random note from grid
      let idx;
      do {
        idx = Math.floor(Math.random() * this.gridNotes.length);
      } while(idx === lastIdx); // Avoid immediate repeat
      lastIdx = idx;
      sequence.push(this.gridNotes[idx]);
    }

    // Schedule them
    let delayAccumulator = 0;

    sequence.forEach((note, i) => {
      // AUDIO
      setTimeout(() => {
        if(this.state === 'GAME') AudioEngine.playTone(note.freq, CONSTANTS.NOTE_DURATION);
      }, delayAccumulator * 1000);

      // VISUAL (Coin)
      // Calculate Y based on our Grid Notes (linear mapping to screen height)
      // Note 0 is bottom, Note Max is top
      const step = this.canvas.height / (this.gridNotes.length + 1);
      const y = this.canvas.height - (this.gridNotes.indexOf(note) + 1) * step;

      // Spawn coin slightly delayed to match audio hearing time
      setTimeout(() => {
        if(this.state === 'GAME') {
          this.coins.push({
            x: this.canvas.width + 50, // Start offscreen right
            y: y,
            freq: note.freq,
            name: note.name,
            collected: false
          });
        }
      }, delayAccumulator * 1000);

      delayAccumulator += (CONSTANTS.NOTE_DURATION + CONSTANTS.NOTE_GAP);
    });
  },

  // --- MAIN LOOP ---
  loop() {
    requestAnimationFrame(this.loop);

    if(this.state === 'RANGE' && this.isListeningRange) {
      this.updateRange();
    } else if(this.state === 'GAME') {
      this.updateGame();
      this.drawGame();
    }
  },

  // --- UPDATE: RANGE ---
  updateRange() {
    const p = AudioEngine.getPitch();
    if(p && p > 60 && p < 1200) {
      if(p < this.rangeMin) this.rangeMin = p;
      if(p > this.rangeMax) this.rangeMax = p;
      
      const elBar = document.getElementById('vrmIndicator');
      const elLow = document.getElementById('vrmLowMarker');
      const elHigh = document.getElementById('vrmHighMarker');

      // Visuals
      // Log scale for better pitch viz
      const minLog = Math.log2(65); // C2
      const maxLog = Math.log2(1046); // C6
      const pLog = Math.log2(p);
      const pct = ((pLog - minLog) / (maxLog - minLog)) * 100;
      elBar.style.bottom = Math.max(0, Math.min(100, pct)) + "%";
      
      elLow.innerText = "Low: " + NoteSys.getFullName(NoteSys.ftom(this.rangeMin));
      elHigh.innerText = "High: " + NoteSys.getFullName(NoteSys.ftom(this.rangeMax));
    }
  },

  // --- UPDATE: GAME ---
  updateGame() {
    // 1. Audio Pitch
    const pitch = AudioEngine.getPitch();
    let hasPitch = false;
    
    // Map pitch to grid range
    const minF = this.gridNotes[0].freq;
    const maxF = this.gridNotes[this.gridNotes.length-1].freq;

    if(pitch) {
      // Octave folding logic (Singing too high/low snaps to grid)
      let f = pitch;
      while(f < minF * 0.8) f *= 2;
      while(f > maxF * 1.2) f /= 2;

      // Smoothing
      this.currFreq = this.currFreq + (f - this.currFreq) * CONSTANTS.SMOOTHING;
      hasPitch = true;
    }

    // 2. Player Y Position
    // We map frequency LOGARITHMICALLY to screen Y
    // Matches the grid rendering exactly
    if(this.currFreq > 0) {
      // Find relative position within grid
      // We essentially interpolate between grid note frequencies
      
      const logCurr = Math.log2(this.currFreq);
      const logMin = Math.log2(minF);
      const logMax = Math.log2(maxF);
      
      // Normalized 0..1
      const norm = (logCurr - logMin) / (logMax - logMin);
      
      // Map to screen pixels (matching grid rendering logic)
      const bottomY = this.canvas.height - (this.canvas.height / (this.gridNotes.length + 1));
      const topY = this.canvas.height / (this.gridNotes.length + 1);
      const rangeH = bottomY - topY;
      
      const targetY = bottomY - (norm * rangeH);
      this.playerY = this.playerY + (targetY - this.playerY) * 0.2;
    }

    // 3. Trail
    if(hasPitch) {
      this.trail.push({ x: 100, y: this.playerY });
    }
    // Move trail
    for(let i=this.trail.length-1; i>=0; i--) {
      this.trail[i].x -= (CONSTANTS.COIN_SPEED/60); // approx per frame
      if(this.trail[i].x < 0) this.trail.splice(i, 1);
    }

    // 4. Coins logic
    let activeCoins = false;
    for(let i=this.coins.length-1; i>=0; i--) {
      let c = this.coins[i];
      c.x -= (CONSTANTS.COIN_SPEED/60);
      
      if(c.x > -50) activeCoins = true;
      else { this.coins.splice(i,1); continue; }

      // Collision
      if(!c.collected && Math.abs(c.x - 100) < 30) {
        // Check Y distance
        if(Math.abs(c.y - this.playerY) < 40) {
          c.collected = true;
          this.score += 100;
          document.getElementById('scoreDisplay').innerText = this.score;
          this.spawnFeedback(c.x, c.y, "PERFECT!");
          this.spawnExplosion(c.x, c.y);
        }
      }
    }

    // 5. Spawn Next Wave?
    if(!activeCoins && this.isSpawning) {
      // Wave complete, wait a moment then spawn
      this.isSpawning = false;
      setTimeout(() => this.spawnSequence(), 1000);
    }
  },

  // --- DRAW: GAME ---
  renderStaticBG() {
    // We create a temporary canvas to pre-render grid
    // This saves massive CPU on mobile
    this.bgCanvas = document.createElement('canvas');
    this.bgCanvas.width = this.canvas.width;
    this.bgCanvas.height = this.canvas.height;
    const ctx = this.bgCanvas.getContext('2d');

    ctx.fillStyle = '#121212';
    ctx.fillRect(0,0, this.canvas.width, this.canvas.height);

    const step = this.canvas.height / (this.gridNotes.length + 1);

    ctx.textAlign = 'right';
    ctx.font = '14px sans-serif';

    this.gridNotes.forEach((n, i) => {
      const y = this.canvas.height - (i + 1) * step;
      
      // Line
      ctx.beginPath();
      ctx.strokeStyle = n.isRoot ? '#444' : '#222'; // Root notes brighter
      ctx.lineWidth = n.isRoot ? 2 : 1;
      ctx.moveTo(0, y);
      ctx.lineTo(this.canvas.width, y);
      ctx.stroke();

      // Text
      ctx.fillStyle = n.isRoot ? '#00e676' : '#555';
      ctx.fillText(n.name, this.canvas.width - 10, y + 5);
    });
  },

  drawGame() {
    // 1. BG
    if(this.bgCanvas) this.ctx.drawImage(this.bgCanvas, 0, 0);

    // 2. Trail
    if(this.trail.length > 1) {
      this.ctx.beginPath();
      this.ctx.strokeStyle = 'rgba(0, 230, 118, 0.5)';
      this.ctx.lineWidth = 4;
      this.ctx.moveTo(this.trail[0].x, this.trail[0].y);
      for(let p of this.trail) this.ctx.lineTo(p.x, p.y);
      this.ctx.stroke();
    }

    // 3. Player
    this.ctx.beginPath();
    this.ctx.fillStyle = '#00e676';
    this.ctx.arc(100, this.playerY, 12, 0, Math.PI*2);
    this.ctx.fill();
    // Glow
    this.ctx.shadowBlur = 15;
    this.ctx.shadowColor = '#00e676';
    this.ctx.stroke();
    this.ctx.shadowBlur = 0;

    // 4. Coins
    this.coins.forEach(c => {
      if(c.collected) return;
      this.ctx.beginPath();
      this.ctx.fillStyle = '#FFD700';
      this.ctx.arc(c.x, c.y, 15, 0, Math.PI*2);
      this.ctx.fill();
      this.ctx.fillStyle = '#000';
      this.ctx.font = '10px sans-serif';
      this.ctx.textAlign = 'center';
      this.ctx.fillText(c.name, c.x, c.y+4);
    });

    // 5. Particles
    this.updateParticles();
  },

  spawnFeedback(x, y, text) {
    const el = document.createElement('div');
    el.className = 'feedback';
    el.innerText = text;
    el.style.left = x + 'px';
    el.style.top = y + 'px';
    el.style.color = '#FFD700';
    document.body.appendChild(el);
    setTimeout(() => el.remove(), 800);
  },

  spawnExplosion(x, y) {
    for(let i=0; i<8; i++) {
      this.particles.push({
        x: x, y: y,
        vx: (Math.random()-0.5)*10, vy: (Math.random()-0.5)*10,
        life: 1.0
      });
    }
  },

  updateParticles() {
    for(let i=this.particles.length-1; i>=0; i--) {
      let p = this.particles[i];
      p.x += p.vx; p.y += p.vy; p.life -= 0.05;
      if(p.life <= 0) { this.particles.splice(i,1); continue; }
      
      this.ctx.globalAlpha = p.life;
      this.ctx.fillStyle = '#FFD700';
      this.ctx.fillRect(p.x, p.y, 4, 4);
      this.ctx.globalAlpha = 1.0;
    }
  },

  endGame() {
    alert("Round Complete! Score: " + this.score);
    this.quitGame();
  }
};

// Start
App.init();

</script>
</body>
</html>
