<!DOCTYPE html><html lang="en"><head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width,initial-scale=1.0, user-scalable=no">
<title>Sing on Pitch!</title>
<style>
  * { box-sizing: border-box; touch-action: none; } /* Prevents mobile scrolling/zooming */
  html, body {
    height: 100%; margin: 0; overflow: hidden; background:#222;
  }
  body {
    color:#fff; font-family:sans-serif; display:flex;
    justify-content: center; align-items: center; height: 100%;
    text-align: center;
  }
  #menu { text-align:center; width: 90%; max-width: 500px; }
  #menu h1 { margin-bottom: 20px; }
  #menu p { margin: 15px 0 5px 0; }

  .settings-group {
    margin-bottom: 20px; padding: 10px; border: 1px solid #444;
    border-radius: 8px; background-color: #2a2a2a;
  }
  .settings-group p { margin-top: 0; margin-bottom: 10px; font-size: 1.1rem; color: #eee;}
  .settings-group button { padding: 8px 15px; font-size: 0.95rem; margin: 3px; }

  .scale-type-selector { display: flex; justify-content: center; margin-bottom: 10px; }
  .scale-type-selector input[type="radio"] { opacity: 0; position: fixed; width: 0; }
  .scale-type-selector label {
    display: inline-block; background-color: #555; padding: 7px 15px; border-radius: 15px;
    cursor: pointer; margin: 0 4px; transition: background-color 0.3s ease; font-size: 0.9rem;
  }
  .scale-type-selector input[type="radio"]:checked + label { background-color: #4caf50; }


  #modeButtons { margin-top: 10px; margin-bottom: 15px; }
  .mode-button {
    display: block; width: 80%; max-width: 300px; margin: 8px auto; text-align: center;
  }
  button, .game-button {
    padding:10px 20px;font-size:1.1rem;margin:6px;border:none;border-radius:8px;cursor:pointer;background:#4caf50;color:#fff;
    transition: background-color 0.2s ease;
   }
  button:hover:not(:disabled), .game-button:hover:not(:disabled) {background:#66bb6a;}
  button:disabled { background: #555; cursor: not-allowed; opacity: 0.7; }

  #gameContainer {
    position: relative; max-width: 100vw; max-height: 100vh;
    display: flex; justify-content: center; align-items: center;
  }
  canvas {
    background: #333; border: 2px solid #fff; border-radius: 8px; display: block;
    image-rendering: -moz-crisp-edges; image-rendering: -webkit-crisp-edges;
    image-rendering: pixelated; image-rendering: crisp-edges; box-sizing: border-box;
  }
  #hud {
    position:absolute; top: 10px; left: 10px; font-size: calc(0.9rem + 0.6vmin);
    user-select:none; white-space:nowrap; z-index: 10; color: #fff;
    background-color: rgba(0,0,0,0.4); padding: 3px 6px; border-radius: 4px;
  }
  #debug {
    position:absolute; top: 10px; right: 10px; font-size: calc(0.8rem + 0.5vmin);
    color:#aaa; text-align:right; z-index: 10; background-color: rgba(0,0,0,0.4);
    padding: 3px 6px; border-radius: 4px;
  }
  .quit-button {
    position: absolute; bottom: 10px; left: 10px; background-color: #f44336;
    padding: calc(5px + 0.4vmin) calc(10px + 0.7vmin); font-size: calc(0.8rem + 0.5vmin);
    z-index: 10;
  }
  .quit-button:hover { background-color: #e57373; }

  .stats-overlay-container {
      position: absolute; left: 50%; top: 50%; transform: translate(-50%, -50%);
      background-color: rgba(0,0,0,0.85); padding: 20px; border-radius: 10px;
      z-index: 30; text-align: center; width: 80%; max-width: 400px;
      border: 1px solid #555;
  }
  .stats-overlay-container h2 { margin-top: 0; color: #4caf50;}
  .stats-overlay-container p { margin: 8px 0; font-size: calc(1rem + 0.5vmin); }
  .stats-overlay-container button { margin-top: 15px; }


  .feedback-text {
    position: absolute; font-size: calc(14px + 0.5vmin); font-weight: bold;
    user-select: none; pointer-events: none; z-index: 20;
    text-shadow: 1px 1px 3px rgba(0,0,0,0.8); opacity: 1;
    transform: scale(0.8) translateY(0);
    transition: opacity 0.3s ease-out, transform 0.3s cubic-bezier(0.18, 0.89, 0.32, 1.28);
  }

  #vocalRangeTestContainer {
    width: 90%; max-width: 500px; padding: 20px; background-color: #333;
    border-radius: 10px; box-shadow: 0 4px 15px rgba(0,0,0,0.4);
    display: flex; flex-direction: column; align-items: center; text-align: center;
  }
  #vocalRangeTestContainer h1 { margin-top: 0; margin-bottom: 20px; color: #4caf50; }
  #vocalRangeTestContainer p { margin: 15px 0 5px 0; line-height: 1.5; }
  #rt_pitchVisualizer {
      width: 90%; height: 150px; background-color: #2a2a2a; border: 1px solid #555;
      margin: 20px auto; position: relative; overflow: hidden; border-radius: 5px;
  }
  #rt_visualizerGuides { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; }
  .rt-guide-line {
      position: absolute; width: 100%; left: 0; border-top: 1px dashed #666;
      font-size: 10px; color: #999; text-align: right; padding-right: 5px;
      box-sizing: border-box; pointer-events: none;
  }
  .rt-guide-line.c-note { border-top: 1px solid #aaa; color: #ccc; }
  .rt-guide-line span { position: absolute; right: 5px; top: -7px; background-color: #2a2a2a; padding: 0 2px; }
  #rt_pitchIndicator {
      position: absolute; left: 0; width: 100%; height: 4px; background-color: #4caf50;
      border-radius: 2px; z-index: 2; bottom: 50%; opacity: 0;
      transition: bottom 0.08s linear, opacity 0.2s ease; box-shadow: 0 0 5px rgba(76, 175, 80, 0.7);
  }
  #rt_results { width: 90%; margin-top: 0; }
  #rt_results div {
    margin: 10px 0; font-size: 1.1rem; padding: 8px; background-color: #444;
    border-radius: 5px; display: flex; justify-content: space-between; align-items: center;
  }
  #rt_results div label { color: #ccc; margin-right: 10px; white-space: nowrap; }
  #rt_results span span { font-weight: bold; color: #ffd700; min-width: 100px; text-align: right; display: inline-block; }
  #rt_results span { text-align: right; }
  #rt_status {
      margin-top: 20px; width: 90%; font-size: 1.1em; font-weight: bold; color: #eee;
      min-height: 3em; padding: 10px; background-color: #2a2a2a; border-radius: 5px;
      display: flex; flex-direction: column; justify-content: center; align-items: center;
      border: 1px solid #555;
  }
  #rt_stabilityIndicator { font-size: 0.9em; color: #aaa; margin-top: 5px; height: 1.2em; }
</style>
</head>
<body>
<div id="menu">
  <h1>Sing on Pitch!</h1>
  <div class="settings-group">
      <p>Game Octave: <span id="currentGameOctaveDisplay">C3 - C4</span></p>
      <button id="octaveDownBtn" title="Octave Down (-12 semitones)">Octave –</button>
      <button id="semitoneDownBtn" title="Semitone Down (-1 semitone)">Note –</button>
      <button id="semitoneUpBtn" title="Semitone Up (+1 semitone)">Note +</button>
      <button id="octaveUpBtn" title="Octave Up (+12 semitones)">Octave +</button>
      <p style="margin-top:15px; margin-bottom: 5px;">Scale Type for Challenges:</p>
      <div class="scale-type-selector">
          <input type="radio" id="scaleMajor" name="scaleType" value="major" checked>
          <label for="scaleMajor">Major</label>
          <input type="radio" id="scaleMinor" name="scaleType" value="minor">
          <label for="scaleMinor">Minor</label>
          <input type="radio" id="scaleChromatic" name="scaleType" value="chromatic">
          <label for="scaleChromatic">Chromatic</label>
      </div>
      <button id="measureRangeBtn" style="margin-top: 15px; font-size: 1rem; padding: 8px 18px;">Measure Vocal Range</button>
  </div>
  <p>Choose game mode (20 melodies per round):</p>
  <div id="modeButtons">
      <button class="mode-button" data-mode="single">1‑Note Challenge</button>
      <button class="mode-button" data-mode="double">2‑Note Challenge</button>
      <button class="mode-button" data-mode="triple">3‑Note Challenge</button>
  </div>
  <p id="status" style="margin-top:10px;font-size:.95rem;color:#bbb;"></p>
</div>

<div id="gameContainer" style="display:none;">
    <canvas id="gameCanvas"></canvas>
    <button id="quitBtn" class="game-button quit-button">Quit</button>
    <div id="hud">Score: <span id="score">0</span>  Melody: <span id="melodyCount">0</span>/20</div>
    <div id="debug"></div>
</div>

<div id="vocalRangeTestContainer" style="display:none;">
  <h1>Vocal Range Measurer</h1>
  <div id="rt_pitchVisualizer"><div id="rt_pitchIndicator"></div><div id="rt_visualizerGuides"></div></div>
  <div id="rt_results">
    <div><label>Current Note:</label><span><span id="rt_currentNote">-</span> (<span id="rt_currentFreq">-</span> Hz)</span></div>
    <div><label>Lowest Note:</label><span><span id="rt_lowestNote">-</span> (<span id="rt_lowestFreq">-</span> Hz)</span></div>
    <div><label>Highest Note:</label><span><span id="rt_highestNote">-</span> (<span id="rt_highestFreq">-</span> Hz)</span></div>
  </div>
  <div id="rt_status">Click "Start" to begin measurement.<div id="rt_stabilityIndicator"></div></div>
  <button id="rt_startButton">Start Measurement</button>
  <button id="rt_resetButton" style="display: none;">Measure Again</button>
  <button id="rt_applyRangeButton" style="display: none; margin-top: 10px;">Use Suggested Octave for Game</button>
  <button id="rt_backToMenuButton" style="margin-top: 10px;">Back to Main Menu</button>
</div>

<script>
// ---------- Game Constants ----------
const TARGET_ASPECT_RATIO = 9 / 16;
const PITCH_HISTORY_SIZE = 5; const SMOOTHING_FACTOR = 0.1;
const LOGICAL_RANGE_SEMITONES = 2; const EPSILON = 0.1;
const PERFECT_CENTS = 12; const GOOD_CENTS = 25; const OKAY_CENTS = 75;
const MAX_SCORE_PER_NOTE = 10; const FEEDBACK_DURATION = 200;
const PARTICLE_COUNT = 8; const PARTICLE_LIFETIME = 0.5; const PARTICLE_GRAVITY = 200;
const YIN_THRESHOLD = 0.20;

const noteDuration=1.0; const melodyGap = 0.0;
const COIN_TIME_TO_CROSS = 1.3; const SEQUENCE_GAP_TIME = 0.6;
const playerXRatio = 0.166; const marginRatio = 0.0625;
let currentMargin = 40; let currentPlayerX = 80;
const PRE_AUDIO_DELAY = 0.05; const VISUAL_DELAY_AFTER_AUDIO = 0.0;
const MAX_INTERVAL_SEMITONES = 7;

const SYNTH_SUSTAIN_DURATION = 0.25; const DECAY_TIME_CONSTANT = 0.25;
const FILTER_START_FREQ = 3500; const FILTER_END_FREQ = 100;
const FLASH_LINE_WIDTH = 7; const FLASH_ALPHA = 0.8; const FLASH_COLOR = '#ffd700';
const FLASH_X_START_RATIO = 0.80; const FLASH_X_END_RATIO = 1.00;

const MAJOR_SCALE_INTERVALS = [0, 2, 4, 5, 7, 9, 11, 12];
const MINOR_SCALE_INTERVALS = [0, 2, 3, 5, 7, 8, 10, 12];
const CHROMATIC_SCALE_INTERVALS = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12];

const MAX_SEQUENCES_PER_ROUND = 20;
const RT_LOW_HIGH_DELAY = 2000;

// ---------- Audio (Shared Global Variables) ----------
let audioCtx = null;
let analyser = null;
let micStream = null;
let buffer = null;
let sampleRate = null;
let masterGain = null;
let isAudioInitialized = false;

// ---------- Game state ----------
let noteRange = [];
let minFreq, maxFreq, logicalMinFreq, logicalMaxFreq, logLogicalMinFreq, logLogicalMaxFreq;
let currentFreq=null, smoothedFreq = null;
let mode='single'; let currentScaleType = 'major';
let currentStartingMidiNote = 48;
const MIN_GAME_MIDI_ROOT = 24; const MAX_GAME_MIDI_ROOT = 72;

let canvas,ctx;
let guideCanvas = null, guideCtx = null;
let player,coins=[], feedbackMessages = [], particles = [], activeFlashes = [];
let trail = []; // NEW: Trail Array
let gameRunning=false, score=0, spawnTimer=0, lastTime=0;
let sequencesPlayed = 0;
let roundStats = { perfect: 0, good: 0, okay: 0, miss: 0 };
let sequenceInFlight=false;
let animationFrameId = null; let pendingTimeouts = []; let rawPitchHistory = [];
let synthStopTime = 0;

let currentDisplayWidth = 0; let currentDisplayHeight = 0; let currentCoinSpeed = 320;

const gameContainer = document.getElementById('gameContainer');
const quitBtn = document.getElementById('quitBtn');
const hud = document.getElementById('hud');
const debug = document.getElementById('debug');
const gameStatusDisplay = document.getElementById('status');
const currentGameOctaveDisplay = document.getElementById('currentGameOctaveDisplay');
const melodyCountDisplay = document.getElementById('melodyCount');

// ---------- Vocal Range Test Variables ----------
const RT_PITCH_HISTORY_SIZE = 5; const RT_MIN_VALID_FREQ = 50; const RT_MAX_VALID_FREQ = 2000;
const RT_STABILITY_DURATION_MS = 500; const RT_STABILITY_CENTS_TOLERANCE = 25;
const RT_VISUALIZER_MIN_FREQ = 60; const RT_VISUALIZER_MAX_FREQ = 1100;
let rt_logVisualizerMinFreq = Math.log2(RT_VISUALIZER_MIN_FREQ);
let rt_logVisualizerMaxFreq = Math.log2(RT_VISUALIZER_MAX_FREQ);
const rt_STATE = { IDLE: 'idle', INITIALIZING: 'initializing', LISTENING_LOW: 'listening_low', LISTENING_HIGH: 'listening_high', DONE: 'done', ERROR: 'error' };
let rt_measurementState = rt_STATE.IDLE; let rt_animationFrameId = null;
let rt_currentFreq = null; let rt_lowestDetectedFreq = null; let rt_highestDetectedFreq = null;
let rt_stablePitchCandidate = null; let rt_stablePitchStartTime = null; let rt_rawPitchHistory = [];
let rt_suggestedGameRootMidi = -1;
let rt_lowHighTransitionTimeout = null;

const vocalRangeTestContainer = document.getElementById('vocalRangeTestContainer');
const rt_startButton = document.getElementById('rt_startButton');
const rt_resetButton = document.getElementById('rt_resetButton');
const rt_applyRangeButton = document.getElementById('rt_applyRangeButton');
const rt_backToMenuButton = document.getElementById('rt_backToMenuButton');
const rt_statusDisplay = document.getElementById('rt_status').firstChild;
const rt_stabilityIndicator = document.getElementById('rt_stabilityIndicator');
const rt_currentNoteDisplay = document.getElementById('rt_currentNote');
const rt_currentFreqDisplay = document.getElementById('rt_currentFreq');
const rt_lowestNoteDisplay = document.getElementById('rt_lowestNote');
const rt_lowestFreqDisplay = document.getElementById('rt_lowestFreq');
const rt_highestNoteDisplay = document.getElementById('rt_highestNote');
const rt_highestFreqDisplay = document.getElementById('rt_highestFreq');
const rt_pitchVisualizer = document.getElementById('rt_pitchVisualizer');
const rt_visualizerGuidesContainer = document.getElementById('rt_visualizerGuides');
const rt_pitchIndicator = document.getElementById('rt_pitchIndicator');

// ---------- Helper Functions ----------
function freqToMidi(f){ return (f && f > 0) ? Math.round(12 * Math.log2(f / 440) + 69) : null; }
function midiToFreq(m) { return 440 * Math.pow(2, (m - 69) / 12); }
function midiName(m){ if (m === null || !isFinite(m)) return '-'; const n = ['C','C#','D','D#','E','F','F#','G','G#','A','A#','B']; const o = Math.floor(m/12) -1; const i = Math.round(m) % 12; return n[i] + o; }
function centsDiff(f1, f2){ if (!f1 || !f2 || f1 <=0 || f2 <= 0) return Infinity; return 1200 * Math.abs(Math.log2(f1 / f2)); }
function getSemitoneDifference(f1, f2) { if (!f1 || !f2) return Infinity; return Math.abs(12 * Math.log2(f1 / f2)); }

// ---------- Canvas Resize ----------
function resizeCanvas() {
    if (!canvas) return;
    const V_PADDING = 10; const H_PADDING = 10;
    const availableWidth = window.innerWidth - H_PADDING; const availableHeight = window.innerHeight - V_PADDING;
    let displayW, displayH;
    if (availableWidth / availableHeight > TARGET_ASPECT_RATIO) { displayH = availableHeight; displayW = displayH * TARGET_ASPECT_RATIO; }
    else { displayW = availableWidth; displayH = displayW / TARGET_ASPECT_RATIO; }
    displayW = Math.floor(displayW); displayH = Math.floor(displayH);
    currentDisplayWidth = displayW; currentDisplayHeight = displayH;
    const dpr = window.devicePixelRatio || 1;

    canvas.width = displayW * dpr; canvas.height = displayH * dpr;
    canvas.style.width = `${displayW}px`; canvas.style.height = `${displayH}px`;

    currentMargin = Math.floor(displayH * marginRatio); currentPlayerX = Math.floor(displayW * playerXRatio);
    currentCoinSpeed = displayW / COIN_TIME_TO_CROSS;

    if (noteRange && noteRange.length > 0) {
      minFreq=noteRange[0].freq; maxFreq=noteRange[noteRange.length-1].freq;
      const factor = Math.pow(2, LOGICAL_RANGE_SEMITONES / 12);
      logicalMinFreq = minFreq / factor; logicalMaxFreq = maxFreq * factor;
      if (logicalMinFreq > 0 && logicalMaxFreq > 0) {
        logLogicalMinFreq = Math.log2(logicalMinFreq); logLogicalMaxFreq = Math.log2(logicalMaxFreq);
      } else {
        logicalMinFreq = midiToFreq(48-LOGICAL_RANGE_SEMITONES);
        logicalMaxFreq = midiToFreq(60+LOGICAL_RANGE_SEMITONES);
        logLogicalMinFreq = Math.log2(logicalMinFreq); logLogicalMaxFreq = Math.log2(logicalMaxFreq);
      }
    } else {
       const defaultRootMidi = 48;
       minFreq = midiToFreq(defaultRootMidi); maxFreq = midiToFreq(defaultRootMidi + 12);
       const factor = Math.pow(2, LOGICAL_RANGE_SEMITONES / 12);
       logicalMinFreq = minFreq / factor; logicalMaxFreq = maxFreq * factor;
       logLogicalMinFreq = Math.log2(logicalMinFreq); logLogicalMaxFreq = Math.log2(logicalMaxFreq);
    }
    if (!guideCanvas) { guideCanvas = document.createElement('canvas'); }
    if (guideCanvas.width !== displayW * dpr || guideCanvas.height !== displayH * dpr) {
        guideCanvas.width = displayW * dpr; guideCanvas.height = displayH * dpr;
        guideCtx = guideCanvas.getContext('2d');
        if (guideCtx) { guideCtx.scale(dpr, dpr); }
    }
    renderGuidesToOffscreenCanvas();

    if (ctx) { ctx.resetTransform(); ctx.scale(dpr, dpr); }
    else { ctx=canvas.getContext('2d'); if (ctx) ctx.scale(dpr, dpr); else { return; }}

    if (gameRunning && ctx) { if (player) player.r = currentDisplayWidth * 0.03; render(); }
}

// ---------- UI wiring ----------
document.querySelectorAll('.mode-button').forEach(button => { button.onclick = () => { startGame(button.getAttribute('data-mode')); };});
quitBtn.onclick = () => goToMenu();
document.getElementById('measureRangeBtn').onclick = () => showVocalRangeTest();
document.getElementById('octaveDownBtn').onclick = () => { currentStartingMidiNote = Math.max(MIN_GAME_MIDI_ROOT, currentStartingMidiNote - 12); updateGameOctaveDisplay(); };
document.getElementById('octaveUpBtn').onclick = () => { currentStartingMidiNote = Math.min(MAX_GAME_MIDI_ROOT, currentStartingMidiNote + 12); updateGameOctaveDisplay(); };
document.getElementById('semitoneDownBtn').onclick = () => { currentStartingMidiNote = Math.max(MIN_GAME_MIDI_ROOT, currentStartingMidiNote - 1); updateGameOctaveDisplay(); };
document.getElementById('semitoneUpBtn').onclick = () => { currentStartingMidiNote = Math.min(MAX_GAME_MIDI_ROOT, currentStartingMidiNote + 1); updateGameOctaveDisplay(); };
document.querySelectorAll('input[name="scaleType"]').forEach(radio => { radio.onchange = () => { currentScaleType = radio.value; };});

function updateGameOctaveDisplay() {
    const rootNoteName = midiName(currentStartingMidiNote);
    const octaveTopNoteName = midiName(currentStartingMidiNote + 12);
    currentGameOctaveDisplay.textContent = `${rootNoteName} - ${octaveTopNoteName}`;
}
updateGameOctaveDisplay();

const resizeHandler = () => { if (gameContainer.style.display !== 'none') resizeCanvas(); };
function clearPendingTimeouts() { pendingTimeouts.forEach(clearTimeout); pendingTimeouts = []; }

function playWarmupSound() {
    if (!audioCtx || audioCtx.state !== 'running' || !masterGain) return;
    const warmupOsc = audioCtx.createOscillator(); const warmupGain = audioCtx.createGain();
    warmupOsc.frequency.value = 1; warmupGain.gain.setValueAtTime(0.00001, audioCtx.currentTime);
    warmupOsc.connect(warmupGain); warmupGain.connect(masterGain);
    const warmupStartTime = audioCtx.currentTime; const warmupDuration = 0.08;
    warmupOsc.start(warmupStartTime); warmupOsc.stop(warmupStartTime + warmupDuration);
    warmupOsc.onended = () => {
        if (warmupOsc?.context?.state !== 'closed') warmupOsc.disconnect();
        if (warmupGain?.context?.state !== 'closed') warmupGain.disconnect();
    };
}

// ---------- AUDIO INITIALIZATION ----------
async function initGameAudio() {
    isAudioInitialized = false;
    let specificErrorMessage = null;
    try {
        if (!audioCtx || audioCtx.state === 'closed') { audioCtx = new(window.AudioContext||window.webkitAudioContext)(); }
        if (audioCtx.state === 'suspended') { await audioCtx.resume(); }
        sampleRate = audioCtx.sampleRate;
        if (!masterGain || masterGain.context?.state === 'closed') { masterGain = audioCtx.createGain(); masterGain.connect(audioCtx.destination); }
        if (micStream) { micStream.getTracks().forEach(track => track.stop()); micStream = null; }
        if (analyser) { try { analyser.disconnect(); } catch(e){} analyser = null; }
        micStream = await navigator.mediaDevices.getUserMedia({ audio: { noiseSuppression: true, echoCancellation: false } });
        const source = audioCtx.createMediaStreamSource(micStream);
        analyser = audioCtx.createAnalyser();
        analyser.fftSize=1024;
        analyser.smoothingTimeConstant = 0.0;
        source.connect(analyser);
        buffer = new Float32Array(analyser.fftSize);
        if (masterGain && audioCtx.state === 'running') { masterGain.gain.setTargetAtTime(1, audioCtx.currentTime, 0.015); }
        gameStatusDisplay.textContent = '';
        isAudioInitialized = true;
        return true;
    } catch (err) {
        specificErrorMessage = `Audio Error: ${err.name}.`;
        gameStatusDisplay.textContent = specificErrorMessage;
        isAudioInitialized = false;
        return false;
    }
}

async function initVrmAudio() {
    isAudioInitialized = false;
    try {
        if (!audioCtx || audioCtx.state === 'closed') { audioCtx = new(window.AudioContext||window.webkitAudioContext)(); }
        if (audioCtx.state === 'suspended') { await audioCtx.resume(); }
        sampleRate = audioCtx.sampleRate;
        if (!masterGain || masterGain.context?.state === 'closed') { masterGain = audioCtx.createGain(); masterGain.connect(audioCtx.destination); }
        if (micStream) { micStream.getTracks().forEach(track => track.stop()); micStream = null; }
        if (analyser) { try { analyser.disconnect(); } catch(e){} analyser = null; }
        micStream = await navigator.mediaDevices.getUserMedia({ audio: { noiseSuppression: true, echoCancellation: false } });
        const source = audioCtx.createMediaStreamSource(micStream);
        analyser = audioCtx.createAnalyser();
        analyser.fftSize=1024;
        analyser.smoothingTimeConstant = 0.0;
        source.connect(analyser);
        buffer = new Float32Array(analyser.fftSize);
        rt_statusDisplay.textContent = '';
        isAudioInitialized = true;
        return true;
    } catch (err) {
        rt_updateStatus(`Audio Error: ${err.name}`, rt_STATE.ERROR);
        isAudioInitialized = false;
        return false;
    }
}


// ---------- PITCH DETECTION ----------
function yinPitchDetection(yinBufferData, sampleRateToUse, threshold = YIN_THRESHOLD) { const bufferSize = yinBufferData.length; const localYinBuffer = new Float32Array(bufferSize / 2); let probability = 0.0; let tauEstimate = -1; for (let tau = 0; tau < localYinBuffer.length; tau++) { localYinBuffer[tau] = 0; for (let i = 0; i < localYinBuffer.length; i++) { const delta = yinBufferData[i] - yinBufferData[i + tau]; localYinBuffer[tau] += delta * delta; } } localYinBuffer[0] = 1; let runningSum = 0; for (let tau = 1; tau < localYinBuffer.length; tau++) { runningSum += localYinBuffer[tau]; if (runningSum === 0) localYinBuffer[tau] = 1; else localYinBuffer[tau] *= tau / runningSum; } for (let tau = 1; tau < localYinBuffer.length; tau++) { if (localYinBuffer[tau] < threshold) { while (tau + 1 < localYinBuffer.length && localYinBuffer[tau + 1] < localYinBuffer[tau]) { tau++; } probability = 1 - localYinBuffer[tau]; tauEstimate = tau; break; } } if (tauEstimate === -1 || probability < threshold) return null; let betterTau; if (tauEstimate > 0 && tauEstimate < localYinBuffer.length - 1) { const y0 = localYinBuffer[tauEstimate - 1]; const y1 = localYinBuffer[tauEstimate]; const y2 = localYinBuffer[tauEstimate + 1]; const adj = (y2 - y0) / (2 * (2 * y1 - y2 - y0)); betterTau = isFinite(adj) ? tauEstimate + adj : tauEstimate; } else { betterTau = tauEstimate; } if (betterTau <= 0) return null; return sampleRateToUse / betterTau; }

function normalizeOctave(freq){ if (!freq || !logicalMinFreq || !logicalMaxFreq || logicalMinFreq <=0 || logicalMaxFreq <=0 || isNaN(logicalMinFreq) || isNaN(logicalMaxFreq) ) { return null;} let currentFreqVal = freq; const lowerBoundOctaveCheck = logicalMinFreq / 4; const upperBoundOctaveCheck = logicalMaxFreq * 4; while (currentFreqVal > upperBoundOctaveCheck && upperBoundOctaveCheck > 0) currentFreqVal /= 2; while (currentFreqVal < lowerBoundOctaveCheck && currentFreqVal > 0) currentFreqVal *= 2; if (currentFreqVal > logicalMaxFreq * 8 || currentFreqVal < logicalMinFreq / 8) return null; return currentFreqVal; }
function getPitch(){ if (!analyser || !micStream || !micStream.active || !buffer || buffer.length === 0) return null; analyser.getFloatTimeDomainData(buffer); const rawFreq = yinPitchDetection(buffer, sampleRate, YIN_THRESHOLD); let medianFreq = null; if (rawFreq !== null) { rawPitchHistory.push(rawFreq); if(rawPitchHistory.length > PITCH_HISTORY_SIZE) rawPitchHistory.shift(); if (rawPitchHistory.length >= Math.floor(PITCH_HISTORY_SIZE / 2) + 1) medianFreq = [...rawPitchHistory].sort((a,b)=>a-b)[Math.floor(rawPitchHistory.length/2)]; else medianFreq = rawFreq; } else rawPitchHistory = []; return medianFreq ? normalizeOctave(medianFreq) : null; }

// ---------- GAME LOGIC ----------
function goToMenu() {
    gameRunning = false;
    if (animationFrameId) cancelAnimationFrame(animationFrameId);
    animationFrameId = null;
    clearPendingTimeouts();
    window.removeEventListener('resize', resizeHandler);
    sequenceInFlight = false;
    spawnTimer = 0;
    if (masterGain && audioCtx?.state === 'running') masterGain.gain.setTargetAtTime(0, audioCtx.currentTime, 0.015);
    isAudioInitialized = false;
    if (micStream) { micStream.getTracks().forEach(track => track.stop()); micStream = null; }
    if (analyser) { try { analyser.disconnect(); } catch(e) {} analyser = null; }
    buffer = null;
    gameContainer.style.display = 'none';
    vocalRangeTestContainer.style.display = 'none';
    document.getElementById('menu').style.display = 'block';
    const statsOverlay = document.getElementById('statsOverlay');
    if (statsOverlay) statsOverlay.remove();
    feedbackMessages.forEach(fb => fb.element?.remove());
    feedbackMessages = [];
    particles = [];
    coins = [];
    activeFlashes = [];
    trail = []; // Clear trail
}

function generateNoteRange(rootMidi, scaleType) { let intervals; if (scaleType === 'major') intervals = MAJOR_SCALE_INTERVALS; else if (scaleType === 'minor') intervals = MINOR_SCALE_INTERVALS; else intervals = CHROMATIC_SCALE_INTERVALS; const newNoteRange = []; for (let i = 0; i < intervals.length; i++) { const noteMidi = rootMidi + intervals[i]; newNoteRange.push({ name: midiName(noteMidi), freq: midiToFreq(noteMidi), midi: noteMidi }); } return newNoteRange; }

async function startGame(selectedMode){
    if (animationFrameId) cancelAnimationFrame(animationFrameId);
    animationFrameId = null;
    mode = selectedMode;
    currentScaleType = document.querySelector('input[name="scaleType"]:checked').value;
    noteRange = generateNoteRange(currentStartingMidiNote, currentScaleType);
    if (!noteRange || noteRange.length === 0) { goToMenu(); return; }

    canvas=document.getElementById('gameCanvas');
    ctx=canvas?.getContext('2d');
    if (!canvas || !ctx) { goToMenu(); return; }

    resizeCanvas();
    window.addEventListener('resize', resizeHandler);
    document.getElementById('menu').style.display='none';
    vocalRangeTestContainer.style.display = 'none';
    gameContainer.style.display='flex';

    const audioReady = await initGameAudio();
    if (!audioReady) { goToMenu(); return; }

    playWarmupSound();
    gameStatusDisplay.textContent = '';
    resetStateAndStats();
    gameRunning = true;
    lastTime=performance.now();
    loop(lastTime);
}

function resetStateAndStats(){
    clearPendingTimeouts();
    const playerRadius = currentDisplayWidth * 0.03;
    player = { x: currentPlayerX, y: currentDisplayHeight / 2, r: playerRadius };
    coins=[];
    score=0;
    sequenceInFlight=false;
    spawnTimer=0;
    currentFreq = null;
    smoothedFreq = null;
    synthStopTime = 0;
    rawPitchHistory = [];
    feedbackMessages.forEach(fb => fb.element?.remove());
    feedbackMessages = [];
    particles = [];
    activeFlashes = [];
    trail = []; // Reset Trail
    sequencesPlayed = 0;
    roundStats = { perfect: 0, good: 0, okay: 0, miss: 0 };
    document.getElementById('score').textContent=score;
    melodyCountDisplay.textContent = sequencesPlayed;
    debug.textContent='';
    quitBtn.style.display='block';
    hud.style.display='block';
    const statsOverlay = document.getElementById('statsOverlay');
    if (statsOverlay) statsOverlay.remove();
}

function loop(t){
    if (!gameRunning) { animationFrameId = null; return; }
    if (!isAudioInitialized || !audioCtx || audioCtx.state !== 'running' || !masterGain || !canvas || !ctx) {
        if (gameRunning) goToMenu(); return;
    }
    animationFrameId = requestAnimationFrame(loop);
    if (audioCtx.state === 'suspended') audioCtx.resume().catch(console.error);
    const dt = t - lastTime; lastTime = t; const dtSeconds = dt / 1000.0; const audioNow = audioCtx.currentTime;
    spawnTimer += dt;
    let processedPitch = null;
    if (audioNow >= synthStopTime && micStream && micStream.active && analyser && buffer) {
        processedPitch = getPitch();
        if (processedPitch !== null && logicalMinFreq && logicalMaxFreq && (processedPitch < logicalMinFreq / 2 || processedPitch > logicalMaxFreq * 2)) { processedPitch = null; }
        if (processedPitch !== null) {
            currentFreq = processedPitch;
            smoothedFreq = (smoothedFreq === null) ? currentFreq : smoothedFreq + (currentFreq - smoothedFreq) * SMOOTHING_FACTOR;
        } else { currentFreq = null; }
    } else { currentFreq = null; if (rawPitchHistory.length > 0 && (audioNow < synthStopTime || !micStream || !micStream.active)) rawPitchHistory = []; }
    if (currentFreq === null) smoothedFreq = null;

    if(currentFreq){
        const midi = freqToMidi(currentFreq); const targetMidiFreq = midi ? midiToFreq(midi) : 0;
        const gameCents = targetMidiFreq ? (1200 * Math.log2(currentFreq / targetMidiFreq)).toFixed(0) : '-';
        debug.textContent=`${midiName(midi)} ${currentFreq.toFixed(1)}Hz (${gameCents}¢)`;
    } else { debug.textContent = (audioNow < synthStopTime) ? 'Synth...' : ((!micStream || !micStream.active || !analyser) ? 'No Mic' : '--- Hz'); }

    if(!player) player = { x: currentPlayerX, y: currentDisplayHeight / 2, r: currentDisplayWidth * 0.03 };
    player.x = currentPlayerX;
    player.y = freqToY(smoothedFreq);

    // --- TRAIL LOGIC ---
    if (smoothedFreq !== null) {
        trail.push({ x: player.x, y: player.y });
    }
    for (let i = trail.length - 1; i >= 0; i--) {
        trail[i].x -= currentCoinSpeed * dtSeconds;
        if (trail[i].x < 0) trail.splice(i, 1);
    }

    updateCoins(dtSeconds);
    checkCollisions();
    maybeSpawnSequence();
    updateParticles(dtSeconds);
    updateFeedback(performance.now());
    updateFlashes(audioNow);
    render(audioNow);

    if (sequencesPlayed >= MAX_SEQUENCES_PER_ROUND && !sequenceInFlight && coins.length === 0 && gameRunning) { endRoundAndShowStats(); }
}

function freqToY(f){
    if (!logLogicalMinFreq || !logLogicalMaxFreq || logLogicalMaxFreq === logLogicalMinFreq || isNaN(logLogicalMinFreq) || isNaN(logLogicalMaxFreq) ) { return currentDisplayHeight / 2; }
    if (f === null || f <= 0) return currentDisplayHeight / 2;
    const logF = Math.log2(Math.max(logicalMinFreq, Math.min(logicalMaxFreq, f)));
    const normalized = (logF - logLogicalMinFreq) / (logLogicalMaxFreq - logLogicalMinFreq);
    if (isNaN(normalized)) return currentDisplayHeight / 2;
    const clampedNormalized = Math.max(0, Math.min(1, normalized));
    return currentDisplayHeight - currentMargin - (clampedNormalized * (currentDisplayHeight - currentMargin * 2));
}

function maybeSpawnSequence(){ if(!gameRunning || sequenceInFlight || coins.length > 0 || sequencesPlayed >= MAX_SEQUENCES_PER_ROUND) return; if(spawnTimer < SEQUENCE_GAP_TIME * 1000) return; spawnTimer = 0; spawnSequence(); }
function spawnSequence(){ if (!gameRunning || !noteRange || noteRange.length === 0 || !audioCtx || !isAudioInitialized) return; sequenceInFlight = true; sequencesPlayed++; melodyCountDisplay.textContent = sequencesPlayed;  const seq=[]; const len = {'single':1, 'double':2, 'triple':3}[mode]; let lastNoteObj = null; const notesForPicking = [...noteRange]; if (notesForPicking.length === 0) { console.error("Cannot pick notes, notesForPicking is empty. noteRange:", noteRange); sequenceInFlight = false; sequencesPlayed--; melodyCountDisplay.textContent = sequencesPlayed; return; } for(let i = 0; i < len; i++) { let nextNoteObj; if (i === 0 || !lastNoteObj) { nextNoteObj = notesForPicking[Math.floor(Math.random() * notesForPicking.length)]; } else { let attempts = 0; do { nextNoteObj = notesForPicking[Math.floor(Math.random() * notesForPicking.length)]; attempts++; if (attempts > 20) break; } while (getSemitoneDifference(lastNoteObj.freq, nextNoteObj.freq) > MAX_INTERVAL_SEMITONES); } seq.push(nextNoteObj); lastNoteObj = nextNoteObj; } let maxPlayStopTime = 0; let currentAudioTime = audioCtx.currentTime; seq.forEach((note, index) => { const playAudioTimestamp = currentAudioTime + PRE_AUDIO_DELAY + index * (noteDuration + melodyGap); const audioTimeoutId = setTimeout(() => { if (gameRunning) playPiano(note.freq, noteDuration); }, Math.max(0, (playAudioTimestamp - currentAudioTime) * 1000)); pendingTimeouts.push(audioTimeoutId); const flashStartTime = playAudioTimestamp; const flashDuration = SYNTH_SUSTAIN_DURATION + DECAY_TIME_CONSTANT * 2; const flashEndTime = flashStartTime + flashDuration; const targetY = freqToY(note.freq); activeFlashes.push({ y: targetY, startTime: flashStartTime, endTime: flashEndTime, duration: flashDuration }); maxPlayStopTime = Math.max(maxPlayStopTime, playAudioTimestamp + noteDuration + DECAY_TIME_CONSTANT * 2.25 + 0.1); }); synthStopTime = Math.max(synthStopTime, maxPlayStopTime); const visualSpawnStartTime = maxPlayStopTime + VISUAL_DELAY_AFTER_AUDIO; seq.forEach((note, index) => { const spawnTimestamp = visualSpawnStartTime + index * (noteDuration + melodyGap); const coinTimeoutId = setTimeout(() => { if(!gameRunning) return; spawnCoin(note, index); if (index === seq.length - 1) sequenceInFlight = false; }, Math.max(0, (spawnTimestamp - currentAudioTime) * 1000)); pendingTimeouts.push(coinTimeoutId); }); }
function spawnCoin(note, index){ if (!gameRunning) return; const targetY = freqToY(note.freq); if(isNaN(targetY)) { return; } const coinRadius = currentDisplayWidth * 0.025; const initialX = currentDisplayWidth; coins.push({ x: initialX, y: targetY, r: coinRadius, note: note }); }
function playPiano(freq, dur){ if (!gameRunning || !audioCtx || audioCtx.state !== 'running' || !masterGain) return; const now = audioCtx.currentTime; const mainGain = audioCtx.createGain(); mainGain.connect(masterGain); const attackEndTime = now + 0.05; const sustainEndTime = attackEndTime + SYNTH_SUSTAIN_DURATION; mainGain.gain.setValueAtTime(0, now); mainGain.gain.linearRampToValueAtTime(0.5, attackEndTime); mainGain.gain.setValueAtTime(0.5, sustainEndTime); mainGain.gain.setTargetAtTime(0, sustainEndTime, DECAY_TIME_CONSTANT); const filter = audioCtx.createBiquadFilter(); filter.type = 'lowpass'; filter.Q.value = 1; filter.connect(mainGain); filter.frequency.setValueAtTime(FILTER_START_FREQ, now); filter.frequency.setTargetAtTime(FILTER_END_FREQ, now + 0.05, DECAY_TIME_CONSTANT * 1.2); const soundEndTime = now + dur + DECAY_TIME_CONSTANT * 5 + 0.1; [1,2,3,4,5].forEach(m=>{ const osc=audioCtx.createOscillator(); osc.type=(m%2===0)?'sine':'triangle'; osc.frequency.value=freq*m; const g=audioCtx.createGain(); g.gain.value=(m===1)?0.6:(0.6/(m*1.8)); osc.connect(g);g.connect(filter);osc.start(now);osc.stop(soundEndTime);osc.onended=()=>{osc.disconnect();g.disconnect();};}); const dId=setTimeout(()=>{if(mainGain?.context?.state!=='closed')mainGain.disconnect();if(filter?.context?.state!=='closed')filter.disconnect();},(soundEndTime-now+0.2)*1000);pendingTimeouts.push(dId);};
function updateCoins(dt){ for(let i = coins.length - 1; i >= 0; i--){ const c = coins[i]; c.x -= currentCoinSpeed * dt; if(c.x < -c.r){ if (gameRunning) recordMiss("Coin missed (off-screen)"); coins.splice(i, 1);}}}
function recordMiss(reason = "Note missed"){ if (!gameRunning) return; roundStats.miss++;}
function checkCollisions(){ if (!gameRunning || currentFreq === null || !player || !audioCtx || audioCtx.currentTime < synthStopTime) return; for(let i = coins.length - 1; i >= 0; i--){ const c=coins[i]; if (c.x + c.r < player.x - player.r) { if (gameRunning) recordMiss("Coin passed player"); coins.splice(i, 1); continue; } if (c.x - c.r <= player.x + player.r && c.x + c.r >= player.x - player.r) { const vDist = Math.abs(player.y - c.y); const cRad = player.r + c.r; if (vDist < cRad) { const diff = Math.abs(centsDiff(currentFreq, c.note.freq)); let pts=0; let fbTxt="Miss"; let fbCol="#ff7777"; let statCat="miss"; if(diff<OKAY_CENTS){pts=Math.floor(MAX_SCORE_PER_NOTE*(1-diff/OKAY_CENTS));pts=Math.max(1,pts);if(diff<PERFECT_CENTS){fbTxt="Perfect!";fbCol="#77ff77";pts=MAX_SCORE_PER_NOTE;statCat="perfect";}else if(diff<GOOD_CENTS){fbTxt="Good";fbCol="#ffff77";statCat="good";}else{fbTxt="Okay";fbCol="#ffcc77";statCat="okay";}} if(pts>0){score+=pts;document.getElementById('score').textContent=score;roundStats[statCat]++;}else recordMiss("Collision, off-pitch"); showFeedback(fbTxt,player.x+player.r,c.y,fbCol);createParticles(player.x+player.r,c.y,PARTICLE_COUNT,fbCol);coins.splice(i,1);}}}}
function showFeedback(text, canvasX, canvasY, color) { if (!gameRunning || !canvas) return; const el = document.createElement('div'); el.className = 'feedback-text'; el.textContent = text; el.style.color = color; const rect = canvas.getBoundingClientRect(); el.style.left = `${rect.left+canvasX+window.scrollX}px`; el.style.top = `${rect.top+canvasY+window.scrollY}px`; document.body.appendChild(el); feedbackMessages.push({element:el,creationTime:performance.now()}); requestAnimationFrame(()=>{el.style.opacity='0';el.style.transform='scale(1.1) translateY(-30px)';});};
function updateFeedback(nowMs) { for (let i=feedbackMessages.length-1;i>=0;i--) { const fb=feedbackMessages[i]; if(nowMs-fb.creationTime > FEEDBACK_DURATION){if(fb.element?.parentNode)fb.element.remove();feedbackMessages.splice(i,1);}}};
function createParticles(x,y,count,color){ if(!gameRunning)return; const baseSpd=currentDisplayWidth*0.35; for(let i=0;i<count;i++){const ang=Math.random()*Math.PI*2;const spd=Math.random()*baseSpd;const sz=currentDisplayWidth*(0.007+Math.random()*0.006);particles.push({x:x,y:y,vx:Math.cos(ang)*spd,vy:Math.sin(ang)*spd-baseSpd*0.5,life:PARTICLE_LIFETIME*(0.75+Math.random()*0.5),color:color,size:sz});}};
function updateParticles(dt){ const grav=PARTICLE_GRAVITY; for(let i=particles.length-1;i>=0;i--){const p=particles[i];p.x+=p.vx*dt;p.y+=p.vy*dt;p.vy+=grav*dt;p.life-=dt;if(p.life<=0)particles.splice(i,1);}};
// OPTIMIZED PARTICLE RENDERER (Rects instead of Arcs)
function renderParticles(){ if(!ctx||particles.length===0)return;particles.forEach(p=>{ctx.fillStyle=p.color;ctx.globalAlpha=Math.max(0,p.life/PARTICLE_LIFETIME);ctx.fillRect(p.x, p.y, p.size, p.size);});ctx.globalAlpha=1.0;};
function updateFlashes(audioNow){ if(!activeFlashes||activeFlashes.length===0)return; for(let i=activeFlashes.length-1;i>=0;i--) if(audioNow>=activeFlashes[i].endTime)activeFlashes.splice(i,1);};
function renderFlashes(audioNow){ if(!ctx||!activeFlashes||activeFlashes.length===0)return;ctx.save();ctx.strokeStyle=FLASH_COLOR;ctx.lineWidth=FLASH_LINE_WIDTH;const x1=currentDisplayWidth*FLASH_X_START_RATIO;const x2=currentDisplayWidth*FLASH_X_END_RATIO;activeFlashes.forEach(f=>{if(audioNow>=f.startTime&&audioNow<f.endTime){const prog=Math.min(1,(audioNow-f.startTime)/f.duration);ctx.globalAlpha=Math.max(0,FLASH_ALPHA*(1-prog));ctx.beginPath();ctx.moveTo(x1,f.y);ctx.lineTo(x2,f.y);ctx.stroke();}});ctx.restore();};
function endRoundAndShowStats(){ if (!gameRunning && document.getElementById('statsOverlay')) return; gameRunning = false; clearPendingTimeouts(); if(animationFrameId)cancelAnimationFrame(animationFrameId);animationFrameId=null; if(masterGain&&audioCtx?.state==='running')masterGain.gain.setTargetAtTime(0,audioCtx.currentTime,0.02); activeFlashes=[]; const overlay=document.createElement('div');overlay.id='statsOverlay';overlay.className='stats-overlay-container';overlay.innerHTML=`<h2>Round Complete!</h2><p>Final Score: ${score}</p><p>Perfect: ${roundStats.perfect}</p><p>Good: ${roundStats.good}</p><p>Okay: ${roundStats.okay}</p><p>Missed: ${roundStats.miss}</p><button id="statsPlayAgainBtn" class="game-button">Play Again</button><button id="statsMainMenuBtn" class="game-button">Main Menu</button>`;gameContainer.appendChild(overlay);document.getElementById('statsPlayAgainBtn').onclick=()=>{overlay.remove();startGame(mode);};document.getElementById('statsMainMenuBtn').onclick=()=>{overlay.remove();goToMenu();};}

function renderGuidesToOffscreenCanvas() {
    if (!guideCtx || !guideCanvas || !logicalMinFreq || !logicalMaxFreq || !noteRange || noteRange.length === 0 || isNaN(logicalMinFreq) || isNaN(logicalMaxFreq) ) {
        if (guideCtx && guideCanvas) { guideCtx.clearRect(0, 0, guideCanvas.width / (window.devicePixelRatio || 1), guideCanvas.height / (window.devicePixelRatio || 1)); }
        return;
    }
    const displayW = currentDisplayWidth;
    const displayH = currentDisplayHeight;
    guideCtx.clearRect(0, 0, displayW, displayH);
    guideCtx.font = `${displayW * 0.023}px sans-serif`;
    guideCtx.textAlign = 'left';
    guideCtx.textBaseline = 'middle';
    const scaleMidiNotesInCurrentOctave = noteRange.map(n => n.midi);
    const minMidiToDraw = Math.ceil(freqToMidi(logicalMinFreq));
    const maxMidiToDraw = Math.floor(freqToMidi(logicalMaxFreq));
    if (minMidiToDraw === null || maxMidiToDraw === null || minMidiToDraw > maxMidiToDraw) return;
    for(let m = minMidiToDraw; m <= maxMidiToDraw; m++) {
        const f = midiToFreq(m);
        const y = freqToY(f);
        if (isNaN(y)) continue;
        const name = midiName(m);
        if (!name) continue;
        const isInSelectedScale = scaleMidiNotesInCurrentOctave.includes(m);
        guideCtx.lineWidth = isInSelectedScale ? 1.5 : 0.75;
        guideCtx.strokeStyle = isInSelectedScale ? '#bbb' : '#666';
        guideCtx.beginPath();
        guideCtx.moveTo(0, y);
        guideCtx.lineTo(displayW, y);
        guideCtx.stroke();
        if(isInSelectedScale){
            guideCtx.fillStyle = '#ddd';
            guideCtx.fillText(name, 5, y - 7);
        }
    }
}

function drawGuides(){
    if (!ctx || !guideCanvas || !gameRunning) return;
    ctx.drawImage(guideCanvas, 0, 0, currentDisplayWidth, currentDisplayHeight);
}

function render(audioNow){
    if (!ctx || !canvas || !isAudioInitialized || !gameRunning) return;
    const dW=currentDisplayWidth; const dH=currentDisplayHeight;
    ctx.clearRect(0,0,dW,dH);

    drawGuides();
    renderFlashes(audioNow);

    // DRAW TRAIL
    if (trail.length > 1) {
        ctx.beginPath();
        ctx.strokeStyle = 'rgba(76, 175, 80, 0.5)';
        ctx.lineWidth = 4;
        ctx.lineCap = 'round';
        ctx.moveTo(trail[0].x, trail[0].y);
        for (let i = 1; i < trail.length; i++) {
            ctx.lineTo(trail[i].x, trail[i].y);
        }
        ctx.stroke();
    }

    ctx.fillStyle='#ffd700';
    coins.forEach(c=>{ctx.beginPath();ctx.arc(c.x,c.y,c.r,0,Math.PI*2);ctx.fill();});
    if(player){const pitchActive=currentFreq!==null&&audioCtx&&audioCtx.currentTime>=synthStopTime;ctx.fillStyle=pitchActive?'#4caf50':'#9e9e9e';ctx.beginPath();ctx.arc(player.x,player.y,player.r,0,Math.PI*2);ctx.fill();}
    renderParticles();
};

// ---------- VRM Logic (Unchanged from original) ----------
rt_freqToVisualizerY = function(f) { if (!f || f <= 0 || !rt_pitchVisualizer) return 0; const logF = Math.log2(f); const norm = (logF - rt_logVisualizerMinFreq) / (rt_logVisualizerMaxFreq - rt_logVisualizerMinFreq); return Math.max(0, Math.min(1, norm)) * 100; };
rt_setupVisualizerGuides = function() { rt_visualizerGuidesContainer.innerHTML = ''; const minMidi = freqToMidi(RT_VISUALIZER_MIN_FREQ); const maxMidi = freqToMidi(RT_VISUALIZER_MAX_FREQ); if (minMidi === null || maxMidi === null) return; for (let m = Math.ceil(minMidi); m <= Math.floor(maxMidi); m++) { const freq = midiToFreq(m); const name = midiName(m); const isCNaturalNote = name && name.startsWith('C') && !name.includes('#'); if (name && !name.includes('#')) { const yP = rt_freqToVisualizerY(freq); const line = document.createElement('div'); line.className = 'rt-guide-line'; if (isCNaturalNote) { line.classList.add('c-note'); const lbl = document.createElement('span'); lbl.textContent = name; line.appendChild(lbl); } line.style.bottom = `${yP}%`; if (yP >= 0 && yP <= 100) rt_visualizerGuidesContainer.appendChild(line); } } };
rt_updateStatus = function(message, state) { rt_measurementState = state; rt_statusDisplay.textContent = message; rt_stabilityIndicator.textContent = (state === rt_STATE.LISTENING_LOW || state === rt_STATE.LISTENING_HIGH) ? 'Hold steady...' : ''; const showStart = (state === rt_STATE.IDLE || state === rt_STATE.ERROR || state === rt_STATE.DONE); const showReset = (state === rt_STATE.DONE || state === rt_STATE.ERROR || state === rt_STATE.LISTENING_LOW || state === rt_STATE.LISTENING_HIGH || state === rt_STATE.INITIALIZING); const showApply = (state === rt_STATE.DONE && rt_suggestedGameRootMidi !== -1); rt_startButton.style.display = showStart ? 'inline-block' : 'none'; rt_resetButton.style.display = showReset ? 'inline-block' : 'none'; rt_applyRangeButton.style.display = showApply ? 'inline-block' : 'none'; rt_startButton.disabled = !(state === rt_STATE.IDLE || state === rt_STATE.ERROR || state === rt_STATE.DONE); rt_resetButton.disabled = false; rt_applyRangeButton.disabled = false; rt_backToMenuButton.disabled = (state === rt_STATE.INITIALIZING); };
rt_updateDisplays = function() { if (rt_measurementState === rt_STATE.LISTENING_LOW || rt_measurementState === rt_STATE.LISTENING_HIGH) { if (rt_currentFreq !== null) { rt_currentFreqDisplay.textContent = rt_currentFreq.toFixed(1); rt_currentNoteDisplay.textContent = midiName(freqToMidi(rt_currentFreq)); } else { rt_currentFreqDisplay.textContent = '-'; rt_currentNoteDisplay.textContent = '-'; } } else { rt_currentFreqDisplay.textContent = '-'; rt_currentNoteDisplay.textContent = '-'; } if (rt_lowestDetectedFreq !== null) { rt_lowestFreqDisplay.textContent = rt_lowestDetectedFreq.toFixed(1); rt_lowestNoteDisplay.textContent = midiName(freqToMidi(rt_lowestDetectedFreq)); } else { rt_lowestFreqDisplay.textContent = '-'; rt_lowestNoteDisplay.textContent = '-'; } if (rt_highestDetectedFreq !== null) { rt_highestFreqDisplay.textContent = rt_highestDetectedFreq.toFixed(1); rt_highestNoteDisplay.textContent = midiName(freqToMidi(rt_highestDetectedFreq)); } else { rt_highestFreqDisplay.textContent = '-'; rt_highestNoteDisplay.textContent = '-'; } if ((rt_measurementState === rt_STATE.LISTENING_LOW || rt_measurementState === rt_STATE.LISTENING_HIGH) && rt_currentFreq !== null) { const yP = rt_freqToVisualizerY(rt_currentFreq); rt_pitchIndicator.style.bottom = `${yP}%`; rt_pitchIndicator.style.opacity = (yP >= 0 && yP <= 100) ? '1' : '0'; } else rt_pitchIndicator.style.opacity = '0'; };
rt_getPitch = function() { if (!analyser || !micStream || !micStream.active || !buffer || buffer.length === 0) return null; analyser.getFloatTimeDomainData(buffer); const rawFreq = yinPitchDetection(buffer, sampleRate, YIN_THRESHOLD); let medianFreq = null; if (rawFreq !== null && rawFreq >= RT_MIN_VALID_FREQ && rawFreq <= RT_MAX_VALID_FREQ) { rt_rawPitchHistory.push(rawFreq); if (rt_rawPitchHistory.length > RT_PITCH_HISTORY_SIZE) rt_rawPitchHistory.shift(); if (rt_rawPitchHistory.length >= Math.floor(RT_PITCH_HISTORY_SIZE/2)+1) medianFreq = [...rt_rawPitchHistory].sort((a,b)=>a-b)[Math.floor(rt_rawPitchHistory.length/2)]; else medianFreq = rawFreq; } else if (rt_rawPitchHistory.length > 0) rt_rawPitchHistory.shift(); if (medianFreq !== null && (medianFreq < RT_MIN_VALID_FREQ || medianFreq > RT_MAX_VALID_FREQ)) return null; return medianFreq; };
rt_measureLoop = function() { if (rt_measurementState !== rt_STATE.LISTENING_LOW && rt_measurementState !== rt_STATE.LISTENING_HIGH) { rt_animationFrameId = null; return; } rt_currentFreq = rt_getPitch(); rt_updateDisplays(); const now = performance.now(); if (rt_currentFreq !== null) { if (rt_stablePitchCandidate === null || centsDiff(rt_currentFreq, rt_stablePitchCandidate) > RT_STABILITY_CENTS_TOLERANCE) { rt_stablePitchCandidate = rt_currentFreq; rt_stablePitchStartTime = now; rt_stabilityIndicator.textContent = 'Hold steady...'; } else { const elapsed = now - rt_stablePitchStartTime; rt_stabilityIndicator.textContent = `Holding: ${Math.round(Math.min(1, elapsed/RT_STABILITY_DURATION_MS)*100)}%`; if (elapsed >= RT_STABILITY_DURATION_MS) { if (rt_measurementState === rt_STATE.LISTENING_LOW) { rt_lowestDetectedFreq = rt_stablePitchCandidate; rt_updateDisplays(); rt_updateStatus(`Lowest: ${midiName(freqToMidi(rt_lowestDetectedFreq))}. Preparing for highest...`, rt_STATE.INITIALIZING); if(rt_lowHighTransitionTimeout) clearTimeout(rt_lowHighTransitionTimeout); rt_lowHighTransitionTimeout = setTimeout(() => { if (rt_measurementState === rt_STATE.INITIALIZING) { rt_updateStatus('Great! Now hum your highest comfortable note.', rt_STATE.LISTENING_HIGH); rt_measureLoop(); } }, RT_LOW_HIGH_DELAY); } else if (rt_measurementState === rt_STATE.LISTENING_HIGH) { if (rt_lowestDetectedFreq !== null && rt_stablePitchCandidate > rt_lowestDetectedFreq) { rt_highestDetectedFreq = rt_stablePitchCandidate; rt_updateDisplays(); const lowMidi = freqToMidi(rt_lowestDetectedFreq); const highMidi = freqToMidi(rt_highestDetectedFreq); let msg = `All done! Range: ${midiName(lowMidi)} - ${midiName(highMidi)}.`; rt_suggestedGameRootMidi = -1; if (lowMidi !== null && highMidi !== null && (highMidi - lowMidi >= 7)) { rt_suggestedGameRootMidi = lowMidi; msg += ` Suggested game octave starts at ${midiName(rt_suggestedGameRootMidi)}.`; } else { msg += ` Range is narrow. Practice!`; } rt_updateStatus(msg, rt_STATE.DONE); } else { rt_updateStatus(`Hum HIGHER than your lowest (${midiName(freqToMidi(rt_lowestDetectedFreq))}).`, rt_STATE.LISTENING_HIGH); rt_stablePitchCandidate=null; rt_stablePitchStartTime=null; rt_stabilityIndicator.textContent=''; } } rt_stablePitchCandidate=null; rt_stablePitchStartTime=null; rt_currentFreq=null; rt_updateDisplays(); } } } else { if(rt_stablePitchCandidate!==null){ rt_stablePitchCandidate=null; rt_stablePitchStartTime=null; rt_stabilityIndicator.textContent=''; } } if(rt_measurementState===rt_STATE.LISTENING_LOW||rt_measurementState===rt_STATE.LISTENING_HIGH) { rt_animationFrameId=requestAnimationFrame(rt_measureLoop); } else { rt_animationFrameId=null; if(rt_pitchIndicator)rt_pitchIndicator.style.opacity='0'; } };
rt_startMeasurement = async function() { if(rt_lowHighTransitionTimeout) clearTimeout(rt_lowHighTransitionTimeout); rt_updateStatus('Initializing Audio...', rt_STATE.INITIALIZING); const audioReady = await initVrmAudio(); if (!audioReady) { return; } rt_resetMeasurementState(); rt_updateDisplays(); rt_updateStatus('Please hum your lowest comfortable note.', rt_STATE.LISTENING_LOW); if (rt_animationFrameId) cancelAnimationFrame(rt_animationFrameId); rt_measureLoop(); };
rt_resetMeasurement = function() { if (rt_animationFrameId) cancelAnimationFrame(rt_animationFrameId); rt_animationFrameId = null; if(rt_lowHighTransitionTimeout) clearTimeout(rt_lowHighTransitionTimeout); rt_resetMeasurementState(); rt_updateDisplays(); rt_updateStatus('Click "Start" to begin measurement.', rt_STATE.IDLE); };
rt_resetMeasurementState = function(){ rt_currentFreq=null; rt_lowestDetectedFreq=null; rt_highestDetectedFreq=null; rt_rawPitchHistory=[]; rt_stablePitchCandidate=null; rt_stablePitchStartTime=null; rt_suggestedGameRootMidi=-1; if(rt_pitchIndicator)rt_pitchIndicator.style.opacity='0';};
showVocalRangeTest = function() { document.getElementById('menu').style.display = 'none'; gameContainer.style.display = 'none'; vocalRangeTestContainer.style.display = 'flex'; rt_init(); };
rt_init = function() { rt_setupVisualizerGuides(); rt_resetMeasurement(); };
rt_returnToMainMenu = function() { if (rt_animationFrameId) cancelAnimationFrame(rt_animationFrameId); rt_animationFrameId = null; if(rt_lowHighTransitionTimeout) clearTimeout(rt_lowHighTransitionTimeout); isAudioInitialized = false; if (micStream) { micStream.getTracks().forEach(track => track.stop()); micStream = null; } if (analyser) { try { analyser.disconnect(); } catch(e) { console.warn("Error disconnecting analyser on rt_returnToMainMenu:", e); } analyser = null; } buffer = null; vocalRangeTestContainer.style.display = 'none'; document.getElementById('menu').style.display = 'block'; rt_resetMeasurementState(); rt_updateStatus('Click "Start" to begin measurement.', rt_STATE.IDLE); };
rt_startButton.addEventListener('click', rt_startMeasurement);
rt_resetButton.addEventListener('click', rt_resetMeasurement);
rt_applyRangeButton.addEventListener('click', () => { if (rt_suggestedGameRootMidi !== -1) { currentStartingMidiNote = Math.max(MIN_GAME_MIDI_ROOT, Math.min(MAX_GAME_MIDI_ROOT, rt_suggestedGameRootMidi)); updateGameOctaveDisplay(); } rt_returnToMainMenu(); });
rt_backToMenuButton.addEventListener('click', rt_returnToMainMenu);

window.addEventListener('load', () => {
    updateGameOctaveDisplay();
    window.addEventListener('resize', resizeHandler);
    if (!navigator.mediaDevices?.getUserMedia) {
        gameStatusDisplay.textContent = 'Error: Mic support missing.';
        document.getElementById('measureRangeBtn').disabled=true;
        document.querySelectorAll('.mode-button').forEach(b=>b.disabled=true);
    } else {
        try {
            if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        } catch(e) {
            gameStatusDisplay.textContent = 'Error: Web Audio API issue.';
            document.getElementById('measureRangeBtn').disabled=true;
            document.querySelectorAll('.mode-button').forEach(b=>b.disabled=true);
        }
    }
    currentScaleType = document.querySelector('input[name="scaleType"]:checked').value;
});
</script>
</body></html>
